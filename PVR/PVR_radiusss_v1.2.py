import arcpy, os
from math import *
  
# input
infeat=arcpy.GetParameterAsText(0)
spoor_feat=arcpy.GetParameterAsText(1)
arcpy.env.workspace=arcpy.GetParameterAsText(2) #the scratch workspace
workspace=arcpy.env.workspace

dist=arcpy.GetParameter(3) #distance for the line features
angle=arcpy.GetParameter(4) #half of the angle between the two lines created

# settings for the environment
arcpy.env.overwriteOutput = True

# definition of functions
def pr(x):
    arcpy.AddMessage(x)

def radius(x1,y1,x2,y2,x3,y3):   #the function determines the position towards the curve
    #the algorithm to determine the center of the circle:
    a=x1**2+y1**2-x2**2-y2**2
    b=x1-x2
    c=y1-y2
    d=x1**2+y1**2-x3**2-y3**2
    e=x1-x3
    f=y1-y3
    xc=(c*d-a*f)/(2*c*e-2*b*f)
    yc=(a-2*xc*b)/(2*c)
    
    #the algorithm to calculate the radius of circle:
    A=sqrt((x1-x2)**2+(y1-y2)**2)
    B=sqrt((x1-x3)**2+(y1-y3)**2)
    C=sqrt((x3-x2)**2+(y3-y2)**2)
    p=(A+B+C)/2
    As=p*(p-A)*(p-B)*(p-C)
    if As>0:
        area=sqrt(As)
        raza=A*B*C/(4*area)
        return raza

def position(x,y,x1,y1,x2,y2,x3,y3):   #the function determines the position towards the curve
    #the algorithm to determine the center of the circle:
    a=x1**2+y1**2-x2**2-y2**2
    b=x1-x2
    c=y1-y2
    d=x1**2+y1**2-x3**2-y3**2
    e=x1-x3
    f=y1-y3
    xc=(c*d-a*f)/(2*c*e-2*b*f)
    yc=(a-2*xc*b)/(2*c)
    
    #the algorithm to calculate the radius of circle:
    A=sqrt((x1-x2)**2+(y1-y2)**2)
    B=sqrt((x1-x3)**2+(y1-y3)**2)
    C=sqrt((x3-x2)**2+(y3-y2)**2)
    p=(A+B+C)/2
    As=p*(p-A)*(p-B)*(p-C)
    if As>0:
        area=sqrt(As)
        raza=A*B*C/(4*area)

        #calculate the distance between the scaned object and the center of circle
        dist=sqrt((x-xc)**2+(y-yc)**2)

        if dist-raza>=0:
            return "outside"
        else:
            return "inside"

# Make a copy of the .sde dataset in the scratch geodatabase
arcpy.FeatureClassToFeatureClass_conversion(infeat, workspace, "PVR_points")
ptScratch=os.path.join(workspace,"PVR_points")
pr("Scratch points dataset was created")

# Create the feature class for the diverging segments and add the needed segments
out_line = "output_line" #the featureclass with lines (+FID +Segm_number fields)
arcpy.CreateFeatureclass_management(workspace, out_line, "Polyline",spatial_reference=ptScratch)
pr("{} feature class was created".format(out_line))
arcpy.AddField_management(out_line,"FID_orig","LONG")
arcpy.AddField_management(out_line,"Segm_number","SHORT")
pr("{}: fields 'FID_orig' and 'Segm_number' fields were created".format(out_line))
pr("{} feature class was created and the 'FID_orig' and 'Segm_number' fields were added".format(out_line))

# Add the near data for the scratch points dataset
arcpy.Near_analysis(ptScratch,spoor_feat,"4 Meters","LOCATION")
pr("Near info updated")

# Create the cursors needed
cursor=arcpy.da.SearchCursor(ptScratch,["OID@","SHAPE@X","SHAPE@Y","NEAR_X","NEAR_Y"]) # to collect the coordinates of the original points and the Near coordinates 
cursor2=arcpy.da.InsertCursor(out_line,["SHAPE@","FID_orig","Segm_number"]) # to add the points generated by the Near tool in a new featureclass

point = arcpy.Point()
array = arcpy.Array()

for row in cursor:
    oid=row[0]
    x=row[1]
    y=row[2]
    xn=row[3]
    yn=row[4]
    if xn<>-1:
        # topographical calculations for the orientation between the measured point(x,y) and the nearest point on spoortak (xn,yn)
        d_y=yn-y
        d_x=xn-x
        
        tetai=degrees(atan(abs(d_x/d_y)))        
        if d_y>0 and d_x>0:
            teta=tetai
        elif d_y<0 and d_x>0:
            teta=180-tetai
        elif d_y<0 and d_x<0:
            teta=tetai+180
        elif d_y>0 and d_x<0:
            teta=360-tetai    

        # coordinates of point P
        teta_ap=teta+angle
        xp=x+dist*sin(radians(teta_ap))
        yp=y+dist*cos(radians(teta_ap))

        # coordinates of point O
        teta_ap=teta-angle
        xo=x+dist*sin(radians(teta_ap))
        yo=y+dist*cos(radians(teta_ap))  
        
        # create two arrays, each with 2 pairs of coordinates to make a segment (between the measured object and point P/O)
            #point P:
        point.X=x
        point.Y=y
        array.add(point)
        point.X=xp
        point.Y=yp
        array.add(point)

        polyline=arcpy.Polyline(array)
        array.removeAll()
        cursor2.insertRow((polyline,oid,1))
        
            #point O:
        point.X=x
        point.Y=y
        array.add(point)
        point.X=xo
        point.Y=yo
        array.add(point)

        polyline=arcpy.Polyline(array)
        array.removeAll()
        cursor2.insertRow((polyline,oid,2))
    else:
        pass
    
del cursor
del cursor2

pr("Diverging segments from the measured points were created.")
# Process: Find all intersection points between spoortak and the newly created lines

intersectInput=[spoor_feat,out_line]
intersectOutput = "points_int"
arcpy.Intersect_analysis(intersectInput, intersectOutput, "ALL", "", "POINT")
pr("Intersection points between spoortak lines and the diverging segments were created")

cursor3=arcpy.da.SearchCursor(ptScratch,["OID@","SHAPE@X","SHAPE@Y"])

def closest_lists(val,lista_len,lista_oid): # this function determines the distances from the the scanned point to all the points resulted from intersection and it creates 
    if sn==val:                             # -> a list with the lengths (to use after the index for the minimum value)   
        length=sqrt((x-x1)**2+(y-y1)**2)    # -> and a list with their oids (to which the index value will be used to extract the closest point)
        lista_len.append(length)
        lista_oid.append(oid1) 

list_segments1=[] # list with all the closest points (oids) that originate from segments with "1" value
list_segments2=[] # list with all the closest points (oids) that originate from segments with "2" value

reinspect_list1=[] #list with objects that generate segments with too big difference in length
reinspect_list2=[] #list with objects that  generate only one or none segments


for row in cursor3:
    oid=row[0]
    x=row[1]
    y=row[2]
    cursor4=arcpy.da.SearchCursor(intersectOutput,["OID@","SHAPE@X","SHAPE@Y","FID_orig","Segm_number"])
    list_len1=[] # list of lengths of the points per segment with value "1" (!) resulted from intersection
    list_len2=[] # list of lengths of the points per segment with value "2" (!) resulted from intersection
    list_oid1=[] # list of oids of the points per segment with value "1" (!) resulted from intersection
    list_oid2=[] # list of oids of the points per segment with value "2" (!) resulted from intersection

    for row1 in cursor4:
        oid1=row1[0]
        x1=row1[1]
        y1=row1[2]
        fid=row1[3]
        sn=row1[4] # segment number value: 1 or 2
        if oid==fid:
            closest_lists(1,list_len1,list_oid1)
            closest_lists(2,list_len2,list_oid2)
    
    if len(list_len1)==0:
        if oid in reinspect_list2:
            pass
        else:
            reinspect_list2.append(oid)
        pr("{}. no points created".format(oid))
    else:
        min_len1=min(list_len1)
        closest_point1=list_oid1[list_len1.index(min_len1)]
        list_segments1.append(closest_point1)
        #pr("{}. {}".format(oid,closest_point1))

    if len(list_len2)==0:
        if oid in reinspect_list2:
            pass
        else:
            reinspect_list2.append(oid)
        pr("{}. no points created".format(oid))
    else:
        min_len2=min(list_len2)
        closest_point2=list_oid2[list_len2.index(min_len2)]
        list_segments2.append(closest_point2)
        #pr("{}. {}".format(oid,closest_point2))
        
    if len(list_len1)>=1 and len(list_len2)>=1:
        if abs(min_len1-min_len2)>=5:                    #checkes the difference in length between the two segments generated per point (segments determined by the scanned point and the closest one)               
            reinspect_list1.append(oid)                  #their oids of the scanned points with this issue are added to a list and these objects should be mannualy inspected
            pr("{}. !!!!CHECK MANUALLY!!!".format(oid))  #usually the points that are in a switch have this problem, but that's ok; the points that are close to the end of the track are the problem!!

    del cursor4
    del row1

arcpy.AddField_management(ptScratch,"Position","TEXT")
arcpy.AddField_management(ptScratch,"Radius","DOUBLE")

# make a dictionary to store all the values below from the intersectoutput feature
cursor6=arcpy.da.SearchCursor(intersectOutput,["OID@","SHAPE@X","SHAPE@Y","FID_orig"])
dictIntersect={}
for row in cursor6:
    if row[0] in list_segments1+list_segments2:
        if row[3] not in dictIntersect:
            dictIntersect[row[3]]=[row[1],row[2]]
        else:
            dictIntersect[row[3]].extend([row[1],row[2]])
pr(dictIntersect)

cursor5=arcpy.da.UpdateCursor(ptScratch,["OID@","SHAPE@X","SHAPE@Y","NEAR_X","NEAR_Y","Radius","Position"])
for row in cursor5:
    oid=row[0]
    x=row[1]
    y=row[2]
    xn=row[3]
    yn=row[4]
    lista_4arc=[x,y,xn,yn] # the initial list for every scanned point that's used for creating the arc; ideally it should contain 4 pairs of coordinates
    if oid in dictIntersect:   
        lista_4arc.extend(dictIntersect[oid])
    pr(str(oid)+". "+str(lista_4arc) +":  length: "+str(len(lista_4arc)))
        
    if len(lista_4arc)==8 and (lista_4arc[2]<>-1 or lista_4arc[3]<>-1) :
        row[5]=radius(*lista_4arc[2:]) # except the measured points coordinates from that list
        cursor5.updateRow(row)
        pr("{}. 'Radius' field was updated".format(oid))        
        if row[5]<6000: # e 5000 de fapt..............!!!
            row[6]=position(*lista_4arc)
            cursor5.updateRow(row)
            pr("{}. 'Position' field was updated".format(oid))            
        else:
            continue            
    
pr("!!! list of objects that generate segments with too big difference in length: {}".format(reinspect_list1))
pr("!!! list with objects that  generate only one or none segments: {}".format(reinspect_list2))

#checkes the difference in length between the two segments generated per point

                                             
